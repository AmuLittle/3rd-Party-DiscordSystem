/* automatically generated by rust-bindgen 0.65.1 */

use ctru_sys::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const C2D_DEFAULT_MAX_OBJECTS: u16 = 4096;
pub type __int64_t = ::libc::c_longlong;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type wint_t = ::libc::c_int;
#[doc = " @struct C3D_FVec\n @brief Float vector\n\n Matches PICA layout"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_FVec {
    pub __bindgen_anon_1: C3D_FVec__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_FVec__bindgen_ty_2,
    #[doc = " @brief Raw access"]
    pub c: [f32; 4usize],
}
#[doc = " @brief Vector access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_1 {
    #[doc = "< W-component"]
    pub w: f32,
    #[doc = "< Z-component"]
    pub z: f32,
    #[doc = "< Y-component"]
    pub y: f32,
    #[doc = "< X-component"]
    pub x: f32,
}
#[doc = " @brief Quaternion access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_2 {
    #[doc = "< Real component"]
    pub r: f32,
    #[doc = "< K-component"]
    pub k: f32,
    #[doc = "< J-component"]
    pub j: f32,
    #[doc = "< I-component"]
    pub i: f32,
}
#[doc = " @struct C3D_Mtx\n @brief Row-major 4x4 matrix"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Mtx {
    #[doc = "< Rows are vectors"]
    pub r: [C3D_FVec; 4usize],
    #[doc = "< Raw access"]
    pub m: [f32; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexCube {
    pub data: [*mut ::libc::c_void; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_Tex {
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: C3D_Tex__bindgen_ty_2,
    pub param: u32_,
    pub border: u32_,
    pub __bindgen_anon_3: C3D_Tex__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_1 {
    pub data: *mut ::libc::c_void,
    pub cube: *mut C3D_TexCube,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_2 {
    pub dim: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 {
    pub height: u16_,
    pub width: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_3 {
    pub lodParam: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 {
    pub lodBias: u16_,
    pub maxLevel: u8_,
    pub minLevel: u8_,
}
impl C3D_Tex {
    #[inline]
    pub fn fmt(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> usize {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: usize) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fmt: GPU_TEXCOLOR, size: usize) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fmt: u32 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FrameBuf {
    pub colorBuf: *mut ::libc::c_void,
    pub depthBuf: *mut ::libc::c_void,
    pub width: u16_,
    pub height: u16_,
    pub colorFmt: GPU_COLORBUF,
    pub depthFmt: GPU_DEPTHBUF,
    pub block32: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_FrameBuf {
    #[inline]
    pub fn colorMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn depthMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_depthMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colorMask: u8_, depthMask: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorMask: u8 = unsafe { ::core::mem::transmute(colorMask) };
            colorMask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let depthMask: u8 = unsafe { ::core::mem::transmute(depthMask) };
            depthMask as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type C3D_RenderTarget = C3D_RenderTarget_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_RenderTarget_tag {
    pub next: *mut C3D_RenderTarget,
    pub prev: *mut C3D_RenderTarget,
    pub frameBuf: C3D_FrameBuf,
    pub used: bool,
    pub ownsColor: bool,
    pub ownsDepth: bool,
    pub linked: bool,
    pub screen: gfxScreen_t,
    pub side: gfx3dSide_t,
    pub transferFlags: u32_,
}
pub type FILE = __FILE;
#[doc = " @brief Subtexture\n  @note If top > bottom, the subtexture is rotated 1/4 revolution counter-clockwise"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tex3DS_SubTexture {
    #[doc = "< Sub-texture width (pixels)"]
    pub width: u16_,
    #[doc = "< Sub-texture height (pixels)"]
    pub height: u16_,
    #[doc = "< Left u-coordinate"]
    pub left: f32,
    #[doc = "< Top v-coordinate"]
    pub top: f32,
    #[doc = "< Right u-coordinate"]
    pub right: f32,
    #[doc = "< Bottom v-coordinate"]
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams {
    pub pos: C2D_DrawParams__bindgen_ty_1,
    pub center: C2D_DrawParams__bindgen_ty_2,
    pub depth: f32,
    pub angle: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_2 {
    pub x: f32,
    pub y: f32,
}
#[doc = "< Plain solid tint color"]
pub const C2D_TintSolid: C2D_TintMode = 0;
#[doc = "< Tint color multiplied by texture color"]
pub const C2D_TintMult: C2D_TintMode = 1;
#[doc = "< Tint color multiplied by grayscale converted texture color"]
pub const C2D_TintLuma: C2D_TintMode = 2;
pub type C2D_TintMode = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Tint {
    #[doc = "< RGB tint color and Alpha transparency"]
    pub color: u32_,
    #[doc = "< Blending strength of the tint color (0.0~1.0)"]
    pub blend: f32,
}
#[doc = "< Top left corner"]
pub const C2D_TopLeft: C2D_Corner = 0;
#[doc = "< Top right corner"]
pub const C2D_TopRight: C2D_Corner = 1;
#[doc = "< Bottom left corner"]
pub const C2D_BotLeft: C2D_Corner = 2;
#[doc = "< Bottom right corner"]
pub const C2D_BotRight: C2D_Corner = 3;
pub type C2D_Corner = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Image {
    pub tex: *mut C3D_Tex,
    pub subtex: *const Tex3DS_SubTexture,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_ImageTint {
    pub corners: [C2D_Tint; 4usize],
}
extern "C" {
    #[doc = " @brief Initialize citro2d\n  @param[in] maxObjects Maximum number of 2D objects that can be drawn per frame.\n  @remarks Pass C2D_DEFAULT_MAX_OBJECTS as a starting point.\n  @returns true on success, false on failure"]
    pub fn C2D_Init(maxObjects: usize) -> bool;
}
extern "C" {
    #[doc = " @brief Deinitialize citro2d"]
    pub fn C2D_Fini();
}
extern "C" {
    #[doc = " @brief Prepares the GPU for rendering 2D content\n  @remarks This needs to be done only once in the program if citro2d is the sole user of the GPU."]
    pub fn C2D_Prepare();
}
extern "C" {
    #[doc = " @brief Ensures all 2D objects so far have been drawn"]
    pub fn C2D_Flush();
}
extern "C" {
    #[doc = " @brief Configures the size of the 2D scene.\n  @param[in] width The width of the scene, in pixels.\n  @param[in] height The height of the scene, in pixels.\n  @param[in] tilt Whether the scene is tilted like the 3DS's sideways screens."]
    pub fn C2D_SceneSize(width: u32_, height: u32_, tilt: bool);
}
extern "C" {
    #[doc = " @brief Resets the model transformation matrix."]
    pub fn C2D_ViewReset();
}
extern "C" {
    #[doc = " @brief Saves the current model transformation matrix.\n @param[out] matrix Pointer to save the current matrix to"]
    pub fn C2D_ViewSave(matrix: *mut C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Restores a previously saved model transformation matrix.\n @param[in] matrix Pointer to matrix to restor"]
    pub fn C2D_ViewRestore(matrix: *const C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Translates everything drawn via the model matrix.\n @param[in] x Translation in the x direction\n @param[in] y Translation in the y direction"]
    pub fn C2D_ViewTranslate(x: f32, y: f32);
}
extern "C" {
    #[doc = " @brief Rotates everything drawn via the model matrix.\n @param[in] rotation Rotation in the counterclockwise direction in radians"]
    pub fn C2D_ViewRotate(rotation: f32);
}
extern "C" {
    #[doc = " @brief Shears everything drawn via the model matrix.\n @param[in] x Shear factor in the x direction\n @param[in] y Shear factor in the y direction"]
    pub fn C2D_ViewShear(x: f32, y: f32);
}
extern "C" {
    #[doc = " @brief Scales everything drawn via the model matrix.\n @param[in] x Scale factor in the x direction\n @param[in] y Scale factor in the y direction"]
    pub fn C2D_ViewScale(x: f32, y: f32);
}
extern "C" {
    #[doc = " @brief Helper function to create a render target for a screen\n  @param[in] screen Screen (GFX_TOP or GFX_BOTTOM)\n  @param[in] side Side (GFX_LEFT or GFX_RIGHT)\n  @returns citro3d render target object"]
    pub fn C2D_CreateScreenTarget(screen: gfxScreen_t, side: gfx3dSide_t) -> *mut C3D_RenderTarget;
}
extern "C" {
    #[doc = " @brief Helper function to clear a rendertarget using the specified color\n  @param[in] target Render target to clear\n  @param[in] color 32-bit RGBA color value to fill the target with"]
    pub fn C2D_TargetClear(target: *mut C3D_RenderTarget, color: u32_);
}
extern "C" {
    #[doc = " @brief Configures the fading color\n  @param[in] color 32-bit RGBA color value to be used as the fading color (0 by default)\n  @remark The alpha component of the color is used as the strength of the fading color.\n          If alpha is zero, the fading color has no effect. If it is the highest value,\n          the rendered pixels will all have the fading color. Everything inbetween is\n          rendered as a blend of the original pixel color and the fading color."]
    pub fn C2D_Fade(color: u32_);
}
extern "C" {
    #[doc = " @brief Configures the formula used to calculate the tinted texture color\n  @param[in] mode Tinting mode\n  @remark Texture tinting works by linearly interpolating between the regular texture color\n          and the tinted texture color according to the blending strength parameter.\n          This function can be used to change how the tinted texture color is precisely\n          calculated, refer to \\ref C2D_TintMode for a list of available tinting modes."]
    pub fn C2D_SetTintMode(mode: C2D_TintMode);
}
extern "C" {
    #[doc = " @brief Draws an image using the GPU (variant accepting C2D_DrawParams)\n  @param[in] img Handle of the image to draw\n  @param[in] params Parameters with which to draw the image\n  @param[in] tint Tint parameters to apply to the image (optional, can be null)\n  @returns true on success, false on failure"]
    pub fn C2D_DrawImage(
        img: C2D_Image,
        params: *const C2D_DrawParams,
        tint: *const C2D_ImageTint,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws a plain triangle using the GPU\n  @param[in] x0 X coordinate of the first vertex of the triangle\n  @param[in] y0 Y coordinate of the first vertex of the triangle\n  @param[in] clr0 32-bit RGBA color of the first vertex of the triangle\n  @param[in] x1 X coordinate of the second vertex of the triangle\n  @param[in] y1 Y coordinate of the second vertex of the triangle\n  @param[in] clr1 32-bit RGBA color of the second vertex of the triangle\n  @param[in] x2 X coordinate of the third vertex of the triangle\n  @param[in] y2 Y coordinate of the third vertex of the triangle\n  @param[in] clr2 32-bit RGBA color of the third vertex of the triangle\n  @param[in] depth Depth value to draw the triangle with"]
    pub fn C2D_DrawTriangle(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        x2: f32,
        y2: f32,
        clr2: u32_,
        depth: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws a plain line using the GPU\n  @param[in] x0 X coordinate of the first vertex of the line\n  @param[in] y0 Y coordinate of the first vertex of the line\n  @param[in] clr0 32-bit RGBA color of the first vertex of the line\n  @param[in] x1 X coordinate of the second vertex of the line\n  @param[in] y1 Y coordinate of the second vertex of the line\n  @param[in] clr1 32-bit RGBA color of the second vertex of the line\n  @param[in] thickness Thickness, in pixels, of the line\n  @param[in] depth Depth value to draw the line with"]
    pub fn C2D_DrawLine(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        thickness: f32,
        depth: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws a plain rectangle using the GPU\n  @param[in] x X coordinate of the top-left vertex of the rectangle\n  @param[in] y Y coordinate of the top-left vertex of the rectangle\n  @param[in] z Z coordinate (depth value) to draw the rectangle with\n  @param[in] w Width of the rectangle\n  @param[in] h Height of the rectangle\n  @param[in] clr0 32-bit RGBA color of the top-left corner of the rectangle\n  @param[in] clr1 32-bit RGBA color of the top-right corner of the rectangle\n  @param[in] clr2 32-bit RGBA color of the bottom-left corner of the rectangle\n  @param[in] clr3 32-bit RGBA color of the bottom-right corner of the rectangle"]
    pub fn C2D_DrawRectangle(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws an ellipse using the GPU\n  @param[in] x X coordinate of the top-left vertex of the ellipse\n  @param[in] y Y coordinate of the top-left vertex of the ellipse\n  @param[in] z Z coordinate (depth value) to draw the ellipse with\n  @param[in] w Width of the ellipse\n  @param[in] h Height of the ellipse\n  @param[in] clr0 32-bit RGBA color of the top-left corner of the ellipse\n  @param[in] clr1 32-bit RGBA color of the top-right corner of the ellipse\n  @param[in] clr2 32-bit RGBA color of the bottom-left corner of the ellipse\n  @param[in] clr3 32-bit RGBA color of the bottom-right corner of the ellipse\n  @note Switching to and from \"circle mode\" internally requires an expensive state change. As such, the recommended usage of this feature is to draw all non-circular objects first, then draw all circular objects."]
    pub fn C2D_DrawEllipse(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_SpriteSheet_s {
    _unused: [u8; 0],
}
pub type C2D_SpriteSheet = *mut C2D_SpriteSheet_s;
extern "C" {
    #[doc = " @brief Load a sprite sheet from file\n  @param[in] filename Name of the sprite sheet file (.t3x)\n  @returns Sprite sheet handle\n  @retval NULL Error"]
    pub fn C2D_SpriteSheetLoad(filename: *const ::libc::c_char) -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Load a sprite sheet from memory\n  @param[in] data Data to load\n  @param[in] size Size of the data to load\n  @returns Sprite sheet handle\n  @retval NULL Error"]
    pub fn C2D_SpriteSheetLoadFromMem(data: *const ::libc::c_void, size: usize) -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Load sprite sheet from file descriptor\n  @param[in] fd File descriptor used to load data\n  @returns Sprite sheet handle\n  @retval NULL Error"]
    pub fn C2D_SpriteSheetFromFD(fd: ::libc::c_int) -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Load sprite sheet from stdio file handle\n  @param[in] f File handle used to load data\n  @returns Sprite sheet handle\n  @retval NULL Error"]
    pub fn C2D_SpriteSheetLoadFromHandle(f: *mut FILE) -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Free a sprite sheet\n  @param[in] sheet Sprite sheet handle"]
    pub fn C2D_SpriteSheetFree(sheet: C2D_SpriteSheet);
}
extern "C" {
    #[doc = " @brief Retrieves the number of sprites in the specified sprite sheet\n  @param[in] sheet Sprite sheet handle\n  @returns Number of sprites"]
    pub fn C2D_SpriteSheetCount(sheet: C2D_SpriteSheet) -> usize;
}
extern "C" {
    #[doc = " @brief Retrieves the specified image from the specified sprite sheet\n  @param[in] sheet Sprite sheet handle\n  @param[in] index Index of the image to retrieve\n  @returns Image object"]
    pub fn C2D_SpriteSheetGetImage(sheet: C2D_SpriteSheet, index: usize) -> C2D_Image;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Sprite {
    pub image: C2D_Image,
    pub params: C2D_DrawParams,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Font_s {
    _unused: [u8; 0],
}
pub type C2D_Font = *mut C2D_Font_s;
extern "C" {
    #[doc = " @brief Load a font from a file\n @param[in] filename Name of the font file (.bcfnt)\n @returns Font handle\n @retval NULL Error"]
    pub fn C2D_FontLoad(filename: *const ::libc::c_char) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load a font from memory\n @param[in] data Data to load\n @param[in] size Size of the data to load\n @returns Font handle\n @retval NULL Error"]
    pub fn C2D_FontLoadFromMem(data: *const ::libc::c_void, size: usize) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load a font from file descriptor\n @param[in] fd File descriptor used to load data\n @returns Font handle\n @retval NULL Error"]
    pub fn C2D_FontLoadFromFD(fd: ::libc::c_int) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load font from stdio file handle\n  @param[in] f File handle used to load data\n  @returns Font handle\n  @retval NULL Error"]
    pub fn C2D_FontLoadFromHandle(f: *mut FILE) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load corresponding font from system archive\n  @param[in] region Region to get font from\n  @returns Font handle\n  @retval NULL Error\n  @remark JPN, USA, EUR, and AUS all use the same font."]
    pub fn C2D_FontLoadSystem(region: CFG_Region) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Free a font\n @param[in] font Font handle"]
    pub fn C2D_FontFree(font: C2D_Font);
}
extern "C" {
    #[doc = " @brief Set a font's texture filter\n @param[in] font Font handle\n @param[in] magFilter the magnification filter\n @param[in] minFilter the minification filter"]
    pub fn C2D_FontSetFilter(
        font: C2D_Font,
        magFilter: GPU_TEXTURE_FILTER_PARAM,
        minFilter: GPU_TEXTURE_FILTER_PARAM,
    );
}
extern "C" {
    #[doc = " @brief Find the glyph index of a codepoint, or returns the default\n @param[in] font Font to search, or NULL for system font\n @param[in] codepoint Codepoint to search for\n @returns Glyph index\n @retval font->cfnt->finf.alterCharIndex The codepoint does not exist in the font"]
    pub fn C2D_FontGlyphIndexFromCodePoint(font: C2D_Font, codepoint: u32_) -> ::libc::c_int;
}
extern "C" {
    #[doc = " @brief Get character width info for a given index\n @param[in] font Font to read from, or NULL for system font\n @param[in] glyphIndex Index to get the width of\n @returns Width info for glyph"]
    pub fn C2D_FontGetCharWidthInfo(
        font: C2D_Font,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
extern "C" {
    #[doc = " @brief Calculate glyph position of given index\n @param[in] font Font to read from, or NULL for system font\n @param[out] out Glyph position\n @param[in] glyphIndex Index to get position of\n @param[in] flags Misc flags\n @param[in] scaleX Size to scale in X\n @param[in] scaleY Size to scale in Y"]
    pub fn C2D_FontCalcGlyphPos(
        font: C2D_Font,
        out: *mut fontGlyphPos_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the font info structure associated with the font\n @param[in] font Font to read from, or NULL for the system font\n @returns FINF associated with the font"]
    pub fn C2D_FontGetInfo(font: C2D_Font) -> *mut FINF_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_TextBuf_s {
    _unused: [u8; 0],
}
pub type C2D_TextBuf = *mut C2D_TextBuf_s;
#[doc = " Text object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Text {
    #[doc = "< Buffer associated with the text."]
    pub buf: C2D_TextBuf,
    #[doc = "< Reserved for internal use."]
    pub begin: usize,
    #[doc = "< Reserved for internal use."]
    pub end: usize,
    #[doc = "< Width of the text in pixels, according to 1x scale metrics."]
    pub width: f32,
    #[doc = "< Number of lines in the text."]
    pub lines: u32_,
    #[doc = "< Number of words in the text."]
    pub words: u32_,
    #[doc = "< Font used to draw the text, or NULL for system font"]
    pub font: C2D_Font,
}
#[doc = "< Matches the Y coordinate with the baseline of the font."]
pub const C2D_AtBaseline: _bindgen_ty_44 = 1;
#[doc = "< Draws text with color. Requires a u32 color value."]
pub const C2D_WithColor: _bindgen_ty_44 = 2;
#[doc = "< Draws text aligned to the left. This is the default."]
pub const C2D_AlignLeft: _bindgen_ty_44 = 0;
#[doc = "< Draws text aligned to the right."]
pub const C2D_AlignRight: _bindgen_ty_44 = 4;
#[doc = "< Draws text centered."]
pub const C2D_AlignCenter: _bindgen_ty_44 = 8;
#[doc = "< Draws text justified. When C2D_WordWrap is not specified, right edge is x + scaleX*text->width. Otherwise, right edge is x + the width specified for those values."]
pub const C2D_AlignJustified: _bindgen_ty_44 = 12;
#[doc = "< Bitmask for alignment values."]
pub const C2D_AlignMask: _bindgen_ty_44 = 12;
#[doc = "< Draws text with wrapping of full words before specified width. Requires a float value, passed after color if C2D_WithColor is specified."]
pub const C2D_WordWrap: _bindgen_ty_44 = 16;
pub type _bindgen_ty_44 = ::libc::c_uint;
extern "C" {
    #[doc = " @brief Creates a new text buffer.\n  @param[in] maxGlyphs Maximum number of glyphs that can be stored in the buffer.\n  @returns Text buffer handle (or NULL on failure)."]
    pub fn C2D_TextBufNew(maxGlyphs: usize) -> C2D_TextBuf;
}
extern "C" {
    #[doc = " @brief Resizes a text buffer.\n  @param[in] buf Text buffer to resize.\n  @param[in] maxGlyphs Maximum number of glyphs that can be stored in the buffer.\n  @returns New text buffer handle (or NULL on failure).\n  @remarks If successful, old text buffer handle becomes invalid."]
    pub fn C2D_TextBufResize(buf: C2D_TextBuf, maxGlyphs: usize) -> C2D_TextBuf;
}
extern "C" {
    #[doc = " @brief Deletes a text buffer.\n  @param[in] buf Text buffer handle.\n  @remarks This also invalidates all text objects previously created with this buffer."]
    pub fn C2D_TextBufDelete(buf: C2D_TextBuf);
}
extern "C" {
    #[doc = " @brief Clears all stored text in a buffer.\n  @param[in] buf Text buffer handle."]
    pub fn C2D_TextBufClear(buf: C2D_TextBuf);
}
extern "C" {
    #[doc = " @brief Retrieves the number of glyphs stored in a text buffer.\n  @param[in] buf Text buffer handle.\n  @returns The number of glyphs."]
    pub fn C2D_TextBufGetNumGlyphs(buf: C2D_TextBuf) -> usize;
}
extern "C" {
    #[doc = " @brief Parses and adds a single line of text to a text buffer.\n  @param[out] text Pointer to text object to store information in.\n  @param[in] buf Text buffer handle.\n  @param[in] str String to parse.\n  @param[in] lineNo Line number assigned to the text (used to calculate vertical position).\n  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n  @returns On success, a pointer to the character on which string processing stopped, which\n           can be a newline ('\\n'; indicating that's where the line ended), the null character\n           ('\\0'; indicating the end of the string was reached), or any other character\n           (indicating the text buffer is full and no more glyphs can be added).\n           On failure, NULL."]
    pub fn C2D_TextParseLine(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Parses and adds a single line of text to a text buffer.\n  @param[out] text Pointer to text object to store information in.\n  @param[in] font Font to get glyphs from, or null for system font\n  @param[in] buf Text buffer handle.\n  @param[in] str String to parse.\n  @param[in] lineNo Line number assigned to the text (used to calculate vertical position).\n  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n  @returns On success, a pointer to the character on which string processing stopped, which\n           can be a newline ('\\n'; indicating that's where the line ended), the null character\n           ('\\0'; indicating the end of the string was reached), or any other character\n           (indicating the text buffer is full and no more glyphs can be added).\n           On failure, NULL."]
    pub fn C2D_TextFontParseLine(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Parses and adds arbitrary text (including newlines) to a text buffer.\n  @param[out] text Pointer to text object to store information in.\n  @param[in] buf Text buffer handle.\n  @param[in] str String to parse.\n  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n  @returns On success, a pointer to the character on which string processing stopped, which\n           can be the null character ('\\0'; indicating the end of the string was reached),\n           or any other character (indicating the text buffer is full and no more glyphs can be added).\n           On failure, NULL."]
    pub fn C2D_TextParse(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Parses and adds arbitrary text (including newlines) to a text buffer.\n  @param[out] text Pointer to text object to store information in.\n  @param[in] font Font to get glyphs from, or null for system font\n  @param[in] buf Text buffer handle.\n  @param[in] str String to parse.\n  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\".\n  @returns On success, a pointer to the character on which string processing stopped, which\n           can be the null character ('\\0'; indicating the end of the string was reached),\n           or any other character (indicating the text buffer is full and no more glyphs can be added).\n           On failure, NULL."]
    pub fn C2D_TextFontParse(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Optimizes a text object in order to be drawn more efficiently.\n  @param[in] text Pointer to text object."]
    pub fn C2D_TextOptimize(text: *const C2D_Text);
}
extern "C" {
    #[doc = " @brief Retrieves the total dimensions of a text object.\n  @param[in] text Pointer to text object.\n  @param[in] scaleX Horizontal size of the font. 1.0f corresponds to the native size of the font.\n  @param[in] scaleY Vertical size of the font. 1.0f corresponds to the native size of the font.\n  @param[out] outWidth (optional) Variable in which to store the width of the text.\n  @param[out] outHeight (optional) Variable in which to store the height of the text."]
    pub fn C2D_TextGetDimensions(
        text: *const C2D_Text,
        scaleX: f32,
        scaleY: f32,
        outWidth: *mut f32,
        outHeight: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Draws text using the GPU.\n  @param[in] text Pointer to text object.\n  @param[in] flags Text drawing flags.\n  @param[in] x Horizontal position to draw the text on.\n  @param[in] y Vertical position to draw the text on. If C2D_AtBaseline is not specified (default), this\n               is the top left corner of the block of text; otherwise this is the position of the baseline\n               of the first line of text.\n  @param[in] z Depth value of the text. If unsure, pass 0.0f.\n  @param[in] scaleX Horizontal size of the font. 1.0f corresponds to the native size of the font.\n  @param[in] scaleY Vertical size of the font. 1.0f corresponds to the native size of the font.\n  @remarks The default 3DS system font has a glyph height of 30px, and the baseline is at 25px."]
    pub fn C2D_DrawText(
        text: *const C2D_Text,
        flags: u32_,
        x: f32,
        y: f32,
        z: f32,
        scaleX: f32,
        scaleY: f32,
        ...
    );
}
